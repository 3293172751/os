# Vim的正则表达式

[toc]

# 关于`magic`

`vim`中有个`magic`的设定。设定方法为：



```shell
:set magic " 设置magic 
:set nomagic " 取消magic 
:h magic " 查看帮助
```

`vim`毕竟是个编辑器，正则表达式中包含的大量元字符如果原封不动地引用（像`perl` 那样）， 势必会给不懂正则表达式的人造成麻烦，比如 `/foo(1)` 命令， 大多数人都用它来查找`foo(1)`这个字符串， 但如果按照正则表达式来解释，被查找的对象就成了 `foo1` 了。

于是，`vim`就规定，正则表达式的元字符必须用反斜杠进行转义才行， 如上面的例子，如果确实要用正则表达式，就应当写成`/foo\(1\)` 。 但是，像`. *` 这种极其常用的元字符，都加上反斜杠就太麻烦了。 而且，众口难调，有些人喜欢用正则表达式，有些人不喜欢用……

为了解决这个问题，`vim`设置了 `magic` 这个东西。简单地说， `magic`就是设置哪些元字符要加反斜杠哪些不用加的。 简单来说：

> **magic**  (\m)：除了`$ . * ^` 之外其他元字符都要加反斜杠。
>  **nomagic** (\M)：除了 `$ ^` 之外其他元字符都要加反斜杠。

这个设置也可以在正则表达式中通过 `\m \M` 开关临时切换。 `\m` 后面的正则表达式会按照 `magic` 处理，`\M` 后面的正则表达式按照 `nomagic` 处理， 而忽略实际的`magic`设置。

例如：



```shell
/\m.* # 查找任意字符串 
/\M.* # 查找字符串 .* （点号后面跟个星号）
```

另外还有更强大的 `\v` 和 `\V`。

`\v` （即 `very magic` 之意）：任何元字符都不用加反斜杠`\V` （即 `very nomagic` 之意）：任何元字符都必须加反斜杠

**例如**：

```shell
/\v(a.c){3}$ # 查找行尾的abcaccadc 
/\m(a.c){3}$ # 查找行尾的(abc){3} 
/\M(a.c){3}$ # 查找行尾的(a.c){3} 
/\V(a.c){3}$ # 查找任意位置的(a.c){3}$
```

默认设置是 `magic`，`vim`也推荐大家都使用`magic`的设置，在有特殊需要时，直接通过`\v\m\M\V` 即可。

对于菜鸟而言,默认的设置足够了,但是对于比较熟悉正则表达式的朋友来说,`\v`自然是上上之选.

# 量词

本文下面使用的元字符都是 `magic`模式(除了`$ . * ^` 之外其他元字符都要加反斜杠)下的,在`very magic`模式下,只需要将`\\`去掉即可.

| vim        | 意义                                                         |
| ---------- | ------------------------------------------------------------ |
| `*`        | 匹配`0`个或多个(匹配优先)                                    |
| `\+`       | 匹配`1`个或多个(匹配优先)                                    |
| `\?`或`\=` | `0`个或`1`个(匹配优先)，`\?`不能在 `?` 命令（逆向查找）中使用 |
| `\{n,m}`   | 匹配`n`个到`m`个(匹配优先),如`\d{1, 3}`可以匹配`1`到`3`个数字,类似`11`, `1`, `333` |
| `\{n,}`    | 最少`n`个(匹配优先)                                          |
| `\{,m}`    | 最多`m`个(匹配优先)                                          |
| `\{n}`     | 恰好`n`个                                                    |

在这里,有些东西需要说明一下,那就是上面的用于限定数量的元字符不单单可以用于字符,同时也可以用于模式,举个例子,下面的模式:



```shell
\(123\)\{2}
```

可以匹配`123123`.

# 一些常用的元字符

| 元字符     | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| `.`        | 匹配任意一个字符,如`p*p`可以匹配字符串`pep`, `pip`或者`pcp`  |
| `[abc]`    | 匹配方括号中的任意一个字符。可以使用-表示字符范围            |
| `[a-z0-9]` | 匹配小写字母和阿拉伯数字                                     |
| `[^abc]`   | 在方括号内开头使用`^`符号，表示匹配除方括号中字符之外的任意字符 |
| `\d`       | 匹配阿拉伯数字，等同于`[0-9]`                                |
| `\D`       | 匹配阿拉伯数字之外的任意字符，等同于`[^0-9]`                 |
| `\x`       | 匹配十六进制数字，等同于`[0-9A-Fa-f]`                        |
| `\w`       | 匹配单词字母，等同于`[0-9A-Za-z_]`                           |
| `\W`       | 匹配单词字母之外的任意字符，等同于`[^0-9A-Za-z_]`            |
| `\t`       | 匹配`<TAB>`字符                                              |
| `\s`       | 匹配空白字符，等同于`[ \t]`                                  |
| `\S`       | 匹配非空白字符，等同于`[^ \t]`                               |
| `\a`       | 所有的字母字符. 等同于`[a-zA-Z]`                             |
| `\l`       | 小写字母`[a-z]`                                              |
| `\L`       | 非小写字母`[^a-z]`                                           |
| `\u`       | 大写字母 `[A-Z]`                                             |
| `\U`       | 非大写字幕`[^A-Z]`                                           |

## 元字符的转义:

`\*` 匹配 `*` 字符
 `\.` 匹配 `.` 字符
 `\/` 匹配 `/` 字符
 `\\` 匹配`\`字符
 `\[` 匹配 `[` 字符

## 表示位置的符号

| 位置元字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| `$`        | 匹配行尾,如`here:$`只会匹配出位于一行结尾的`here:`.          |
| `^`        | 匹配行首,如`^Part`只会匹配出位于一行开头的`Part`.            |
| `\<` `\>`  | 会匹配出以某些字符开头的(`\<`)或结尾(`\>`)的单词.`\<ac`只会匹配出以`ac`开头的单词,如`action`,而`ac>/`只会匹配出以`ac`结尾的单词,如`maniac`.`\<action\>`会匹配出`action`这个单词.单词的开头和结尾,是用标点符号或空格来分隔的. |

## 替换变量

在正规表达式中使用 `\(` 和 `\)` 符号括起正规表达式，即可在后面使用`\1`、`\2`等变量来访问 `\(` 和 `\)` 中的内容。这种形式实际上是将`\(`与`\)`中的模式保存到了特殊的空间(称之为"保留缓冲区").这种方法可以保存任意一行中的`9`个模式.

举个例子,对于下面的模式:

```shell
\(That\) or \(this\)
```

会将`That`存放到缓冲区`1`中,而将`this`保存到保留缓冲区`2`中,这些保留的模式在以后可以用`\1`到`\9`的序列重新排列,例如,如果要将`That or this`改成`this or That`,可以键入:

```shell
:%s/\(That\) or \(this\)/\2 or \1/
```

也可以实现在搜索或者替换字符串时使用\n表示法:

```shell
:%s\(abcd\)\1/alphabet-soup/
```

可以将`abcdabcd`替换为`alphabet-soup`.这里需要特别注意一下,`\0`表示我们所匹配的所有内容.



# 非贪婪匹配

非贪婪匹配也是正则表达式中一个非常强大的特性,我这里稍微来记录一下`vim`中非贪婪匹配的语法.
 假设我有这样一段文本:

```c
map<wstring, wstring> grammarTokens = {
    {L"_LPAR", L"\\("},
    {L"_RPAR", L"\\)"},
    {L"_LBRA", L"\\["},
    {L"_RBRA", L"\\]"},
    {L"OP", L"[+?]"},
    {L"_COLON", L":"},      // 冒号
    {L"_OR", L"\\|"},
    {L"_DOT", L"\\."},
    {L"RULE", L"!?[_?]?[a-z][_a-z0-9]*"},  // 用于表示普通的规则
    {L"TOKEN", L"_?[A-Z][_A-Z0-9]*"},
    {L"REGEXP", L"/(?!/)(\\/|\\\\|[^/\n])*?/i?"},
    {L"_NL", L"(\r?\n)+\s*"},
    {L"WS", L"[\t]+"},
    {L"COMMENT", L"//[^\n]*"},
    {L"_TO", L"-->"},
    {L"_IGNORE", L"%ignore"},
    {L"_IMPORT", L"%import"}
};
```

上面的这段`c++`代码片段实际上是存在错误的,要将所有的字符都变成这样`wstring(L"xxxx")`,才能消除错误,所以,我们想到了,正则表达式正好可以用来干这个事情.

最开始的时候,我使用的是这种语法:

```ruby
:%s/\(L".*"\)/wstring(\1)/g
```

结果很有意思:

```c
map<wstring, wstring> grammarTokens = {
    {wstring(L"_LPAR", L"\\(")},
    {wstring(L"_RPAR", L"\\)")},
    {wstring(L"_LBRA", L"\\[")},
    {wstring(L"_RBRA", L"\\]")},
    {wstring(L"OP", L"[+?]")},
    {wstring(L"_COLON", L":")},     // 冒号
    {wstring(L"_OR", L"\\|")},
    {wstring(L"_DOT", L"\\.")},
    {wstring(L"RULE", L"!?[_?]?[a-z][_a-z0-9]*")},  // 用于表示普通的规则
    {wstring(L"TOKEN", L"_?[A-Z][_A-Z0-9]*")},
    {wstring(L"REGEXP", L"/(?!/)(\\/|\\\\|[^/\n])*?/i?")},
    {wstring(L"_NL", L"(\r?\n)+\s*")},
    {wstring(L"WS", L"[\t]+")},
    {wstring(L"COMMENT", L"//[^\n]*")},
    {wstring(L"_TO", L"-->")},
    {wstring(L"_IGNORE", L"%ignore")},
    {wstring(L"_IMPORT", L"%import")}
};
```

这个显然是超乎我们预期的,原因在于正则表达式中`.*`是贪婪匹配,什么意思呢,也就是说,这个表达式会一直向前匹配,匹配尽可能多的文本.
 以`{L"_LPAR", L"\\("}`这一行为例,用`\(L".*"\)`来进行匹配的时候,`L`匹配`L`, `"`匹配`"`,然后`.`可以匹配任意的字符,`*`代表重复零次或者多次,因此,这里匹配了`_LPAR`,虽然下一个`"`可以和正则式的`"`相匹配,如果此时停下来,是完全合理的,但是所谓的贪婪,就体现在了这里,我要一直尝试,一定要匹配更多的字符,所以继续前进,`.*`匹配了`_LPAR",L"\\(`,一直到下一个`"`,正则表达式发现如果我继续用`.*`来匹配掉`"`的话,那么在这一行,我的匹配会失败,所以不能继续了,所以用正则表达式中的`"`匹配`"`,匹配成功.

你可能会疑问,为什么`.*`不匹配到下一行,下下行,我只能说,`vim`的正则表达式是一行一行进行匹配的.

所以人们为了避免这种情况,提出了一个非贪婪匹配的概念,核心是,匹配尽可能少的字符.

所以在这里,我们要将其替换为非贪婪匹配,非贪婪匹配的语法很奇葩,是这样的`\{-}`,我们要将前面的`.*`变成`.\{-}`,所以命令变成了:

```ruby
:%s/\(L".\{-}"\)/wstring(\1)/g
```

或者使用`very magic`模式,也可以达到同样的效果:

```shell
:%s/(L.{-})/wstring(\1)/g
```

结果非常漂亮:

```c
map<wstring, wstring> grammarTokens = {
    {wstring(L"_LPAR"), wstring(L"\\(")},
    {wstring(L"_RPAR"), wstring(L"\\)")},
    {wstring(L"_LBRA"), wstring(L"\\[")},
    {wstring(L"_RBRA"), wstring(L"\\]")},
    {wstring(L"OP"), wstring(L"[+?]")},
    {wstring(L"_COLON"), wstring(L":")},        // 冒号
    {wstring(L"_OR"), wstring(L"\\|")},
    {wstring(L"_DOT"), wstring(L"\\.")},
    {wstring(L"RULE"), wstring(L"!?[_?]?[a-z][_a-z0-9]*")},  // 用于表示普通的规则
    {wstring(L"TOKEN"), wstring(L"_?[A-Z][_A-Z0-9]*")},
    {wstring(L"REGEXP"), wstring(L"/(?!/)(\\/|\\\\|[^/\n])*?/i?")},
    {wstring(L"_NL"), wstring(L"(\r?\n)+\s*")},
    {wstring(L"WS"), wstring(L"[\t]+")},
    {wstring(L"COMMENT"), wstring(L"//[^\n]*")},
    {wstring(L"_TO"), wstring(L"-->")},
    {wstring(L"_IGNORE"), wstring(L"%ignore")},
    {wstring(L"_IMPORT"), wstring(L"%import")}
};
```

错误消除.

# 环视,或者说正向预查,反向预查

在各种常用工具对比中，我看到`vim`是支持计数的，而且似乎大部分常用的正则元字符都与`perl`兼容，比如`\s`,`\d`,`\D`,`\w`,`\W`, `<` `>`。但`vim`不支持`\b`，即单词边界。另外，`vim`中比较麻烦的是它似乎支持的是`BRE`（基本正则表达式，`posix`定义的），`BRE`中所有括号都不是元字符，因为作为元字符的是`\(`,`\{`。比如`vim`中匹配连续`3`个`9`，你得用`9\{3\}`，原来我一直以为不支持，但我还是觉得麻烦了一点，`grep`默认也是使用的这种`BRE` 。

与`perl`相比，`vim`将`(?`换成了`\@`，并且这个符号应该跟在匹配模式的后边。下面是一组对比:

|     vim     |  Perl  |                          意义                          | 例子                                                         |
| :---------: | :----: | :----------------------------------------------------: | :----------------------------------------------------------- |
|    `\@=`    | `(?=`  |                        顺序环视                        | 查找后面是`sql`的`my`： `/my\(sql\)\@=`                      |
|    `\@!`    | `(?!`  |                      顺序否定环视                      | 查找后面不是`sql`的`my`： `/my\(sql\)\@!`                    |
|   `\@<=`    | `(?<=` |                        逆序环视                        | 查找前面是`my`的`sql`： `/\(my\)\@<=sql`                     |
|   `\@<!`    | `(?<!` |                      逆序否定环视                      | 查找前面不是`my`的`sql`： `/\(my\)\@<!sql`                   |
|    `\@>`    | `(?>`  |                        固化分组                        |                                                              |
| `\%(atom\)` | `(?:`  | 非捕获型括号(此分组不捕获，可以理解为不算在分组信息中) | `:%s/\%(my\)sql\(ok\)/\1`这个命令会将`mysqlok`替换为 `ok` ，由于`my`为捕获在分组中，故组中`\1` 为`ok`。 |

正如前面所说的,如果使用`very magic`模式的话,这些命令都将大大简化,因为我们可以省略掉大量的转义字符,以`:%s/\%(my\)sql\(ok\)/\1`为例,它可以替换成`%s/\v%(my)sql(ok)/\1`,是不是清晰很多了呢.

# 常用的替换命令

删除所有的空白行

```shell
:g/^$/d
```



```bash
1，简单替换表达式
替换命令可以在全文中用一个单词替换另一个单词：
:%s/four/4/g

“%” 范围前缀表示在所有行中执行替换。最后的 “g” 标记表示替换行中的所有匹配点。如果仅仅对当前行进行操作，那么只要去掉%即可

如果你有一个象 “thirtyfour” 这样的单词，上面的命令会出错。这种情况下，这个单词会被替换成”thirty4″。要解决这个问题，用 “\<” 来指定匹配单词开头：
:%s/\<four/4/g

显然，这样在处理 “fourty” 的时候还是会出错。用 “\>” 来解决这个问题：
:%s/\<four\>/4/g

如果你在编码，你可能只想替换注释中的 “four”，而保留代码中的。由于这很难指定，可以在替换命令中加一个 “c” 标记，这样，Vim 会在每次替换前提示你：
:%s/\<four\>/4/gc

2，删除多余的空格
要删除这些每行后面多余的空格，可以执行如下命令：
:%s/\s\+$//

命令前面指明范围是 “%”，所以这会作用于整个文件。”substitute” 命令的匹配模式是
“\s\+$”。这表示行末（$）前的一个或者多个（\+）空格（\s）。替换命令的 “to” 部分是空的：”//”。这样就会删除那些匹配的空白字符。

3，匹配重复性模式
星号项 “*” 规定在它前面的项可以重复任意次。因此:
/a*

匹配 “a”，”aa”，”aaa”，等等。但也匹配 “” (空字串)，因为零次也包含在内。星号 “*” 仅仅应用于那个紧邻在它前面的项。因此 “ab*” 匹配 “a”，”ab”，”abb”,”abbb”，等等。如要多次重复整个字符串，那么该字符串必须被组成一个项。组成一项的方法就是在它前面加 ““，后面加“”。因此这个命令:
/ab*

匹配: “ab”，”abab”，”ababab”，等等。而且也匹配 “”。

要避免匹配空字串，使用 “\+”。这表示前面一项可以被匹配一次或多次。
/ab\+

匹配 “ab”，”abb”，”abbb”，等等。它不匹配 后面没有跟随 “b” 的 “a”。

要匹配一个可选项，用 “\=”。 例如:
/folders\=

匹配 “folder” 和 “folders”。

4，指定重复次数
要匹配某一项的特定次数重复，使用 “\{n,m}” 这样的形式。其中 “n” 和 “m” 都是数字。在它前面的那个项将被重复 “n” 到 “m” 次 (|inclusive| 包含 “n” 和 “m”)。例如:
/ab\{3,5}

匹配 “abbb”，”abbbb” 以及 “abbbbb”。

当 “n” 省略时，被默认为零。当 “m” 省略时，被默认为无限大。当 “,m” 省略时，就表示重复正好 “n” 次。例如:

模式 匹配次数

\{,4} 0，1，2，3 或 4

\{3,} 3，4，5，等等

\{0,1} 0 或 1，同 \=

\{0,} 0 或 更多，同 *

\{1,} 1 或 更多，同 \+

\{3} 3

5，多选一匹配

在一个查找模式中，”或” 运算符是 “\|”。例如:
/foo\|bar

这个命令匹配了 “foo” 或 “bar”。更多的抉择可以连在后面:
/one\|two\|three

匹配 “one”，”two” 或 “three”。
如要匹配其多次重复，那么整个抉择结构须置于 “”和“” 之间:
/foo∥bar\+

这个命令匹配 “foo”，”foobar”，”foofoo”，”barfoobar”，等等。

再举个例子:
/endif∥while∥for
这个命令匹配 “endif”，”endwhile” 和 “endfor”。
```



# 宏

#### 录制宏

假设待操作的文本文件如下，需要将如下多行文本的行首键入一个tab。



```csharp
set nu
set tabstop=4
set shiftwidth=4
set softtabstop=4
set autoindent
set mouse=i
syntax on
```

1. 先将光标移动到第一行。
2. 在normal模式下，按q加一个字母开始录制。例如按下qr，将该宏注册为r。
3. 按下I在行首插入，在编辑模式按下Tab键。按Esc键返回到normal模式。
4. 按下j将光标移动到下一行。
5. 按下q完成录制。

即宏的录制是以q加一个注册字母开始，录制操作过程，并在normal模式以q完成录制。

#### 使用宏

使用上面录制的宏r

normal模式下将光标移动到第二行，按下@r，使用了一次宏r。

多次操作按下数字加@r，例如将光标移动到第三行，对余下的5行操作宏r，按下5@r

@@是对上一次宏使用的重复使用。

